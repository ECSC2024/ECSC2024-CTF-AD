#!/usr/bin/env python3
#
# @mebeim - simple attacker example script
#

import asyncio
import os
import requests
import re
import sys
from collections import defaultdict, deque
from random import shuffle
from subprocess import Popen, PIPE, DEVNULL
from time import monotonic


# These are taken from environment in main()
MY_TEAM_ID = None  # Needed to not attack yourself
TEAM_TOKEN = None  # Needed if not a dry run
DRY_RUN    = False # If True the flags are not submitted, just printed

SERVICE_NAME = 'Sanromolo'
FLAG_SUBMIT_INTERVAL = 15
FLAG_QUEUE: deque[str] = deque()
FLAGS_SEEN = set()
EXPLOITS = [
	'./expl_lock_byte_lock.py',
	'./expl_stack_reuse.py'
]


def get_attack_jobs():
	r = requests.get('http://10.10.0.1:8081/flagIds?service=' + SERVICE_NAME)
	data = r.json()[SERVICE_NAME]
	jobs = defaultdict(list)

	for team_id, flag_ids_per_tick in data.items():
		for flag_id in flag_ids_per_tick.values():
			jobs[int(team_id)].append(flag_id['event_id'])

	return jobs


def submit_flags(flags):
	if DRY_RUN:
		return '[dry run] Submitted flags: ' + repr(flags)
	return requests.put('http://10.10.0.1:8080/flags', headers={
		'X-Team-Token': TEAM_TOKEN
	}, json=flags).text


async def submit_job():
	while 1:
		while not FLAG_QUEUE:
			await asyncio.sleep(1)

		flags = list(FLAG_QUEUE)
		FLAG_QUEUE.clear()

		print(f'[SUBMIT] Submitting: {flags}')
		result = submit_flags(flags)
		print(f'[SUBMIT] Result: {result}')
		await asyncio.sleep(FLAG_SUBMIT_INTERVAL)


async def team_job(team_id, event_ids):
	team_ip = f'10.60.{team_id}.1'
	exploits = EXPLOITS[:]
	shuffle(exploits)

	for event_id in event_ids:
		for exploit in exploits:
			print(f'[TEAM {team_id}] Getting flag for {event_id=} with {exploit=}')

			try:
				proc = Popen([exploit, team_ip, event_id], text=True, stdout=PIPE, stderr=DEVNULL)
				deadline = monotonic() + 30

				while proc.poll() is None:
					await asyncio.sleep(0.1)

					if monotonic() > deadline:
						print(f'[TEAM {team_id}] Exploit timed out!')
						proc.kill()
						break
				else:
					out = proc.stdout.read()
					flags = re.findall(r'[A-Z0-9]{31}=', out)
					expl_worked = bool(flags)
					flags = list(filter(lambda f: f not in FLAGS_SEEN, flags))

					if flags:
						print(f'[TEAM {team_id}] Got new flags:', flags)
						FLAGS_SEEN.update(flags)
						FLAG_QUEUE.extend(flags)

					# Avoid next exploit, we got the flag with this one
					if expl_worked:
						break

			except Exception as e:
				print(f'[TEAM {team_id}] Exception: {e}')


async def attack_round():
	jobs = get_attack_jobs()
	tasks = []

	for team_id, event_ids in jobs.items():
		if team_id == MY_TEAM_ID:
			continue

		tasks.append(team_job(team_id, event_ids))

	await asyncio.gather(*tasks)


async def main():
	# Keep a ref to the task so it doesn't get GC'd (according to Python docs)
	x = asyncio.ensure_future(submit_job())

	while True:
		await attack_round()


if __name__ == '__main__':
	MY_TEAM_ID = int(os.environ.get('MY_TEAM_ID', -999))
	if MY_TEAM_ID == -999:
		sys.exit('Need MY_TEAM_ID env var!')

	DRY_RUN = os.environ.get('DRY_RUN', False)
	if DRY_RUN in ('1', 'true'):
		DRY_RUN = True
		print('Performing dry run (not submitting flags)', file=sys.stderr)
	else:
		TEAM_TOKEN = os.environ.get('TEAM_TOKEN')
		if TEAM_TOKEN is None:
			sys.exit('Need TEAM_TOKEN env var (or use DRY_RUN=1)!')

	asyncio.run(main())
