# Sanromolo - Exploits

The Python scripts in this directory contain working exploits for the 2
vulnerabilites of the service.

Additionally, [`simple_attacker.py`](./simple_attacker.py) provides a simple
weaponization of the two exploits to run on multiple teams in parallel with
automatic flag submission.


## Exploit 1 - Unchecked NFC tag lock bits

[`expl_lock_byte_lock.py`](./expl_lock_byte_lock.py) exploits the missing check
on the lock bytes write in the
[`event-management`](../../services/Sanromolo/dist/event-management) binary.

As discussed in [the writeup](../../sources/Sanromolo/README.md), the goal is to
lock the `lock_bytes` themselves to stop the `event-management` code from
succesfully locking the seat page, keeping it writable and allowing for it to be
changed after entering the event.

The code connects to the wallet, buys a normal user ticket for the target event,
then locks the `lock_bytes` page with a write. A connection is then established
to the `event-management` service, the event is joined and a seat is assigned.
Since the ticket is now writable as the service failed to lock the user pages,
the exploit simply replaces the assigned seat with one in the range [0,99] (in
this case 10), and proceeds to enter the event as VIP and get the flag.


## Exploit 2 - Missing error check + uninitialized stack reuse

[`expl_stack_reuse.py`](./expl_stack_reuse.py) exploits the missing error check
leading to uninitialized stack reuse in the `Read` command handler of the
[`wallet`](../../services/Sanromolo/dist/wallet) binary.

As discussed in [the writeup](../../sources/Sanromolo/README.md), the goal is to
leak a valid VIP invitation code by providing a carefully crafter `user` name to
the `buy_vip_ticket()` function and then trying to read pages from a
non-existing ticket in `read_page()`.

Things in the two stack frames overlap as follows (with `read_page()` reusing
the data left by `buy_vip_ticket()` (the interesting parts are highlighted with
a `X` in the middle):

```none
STACK FRAME OF buy_vip_ticket()  |  STACK FRAME OF read_page()
[...]                            |
event_id[8:16]                   |
seat, user[0:4]                  |
user[4:12]                       |
user[12:20]                      |
user[20:28]                      X  manufacturer, serial[0:2], check_byte_1, serial[2:4]
event name ptr                   |  serial[2:6], check_byte_2, internal, lock
event_id[0:8]                    |  event_id[0:8]
event_id[8:16]                   |  event_id[8:16]
star signature ptr               |  seat, user[0:4]
vip_invitation_code[0:8]         X  user[4:12]
vip_invitation_code[8:16]        X  user[12:20]
                                 |  user[20:28]
```

In order to pass the `nfc_verify_tag()` check in `read_page()`, the user name
that we provide to `buy_vip_ticket()` should end with 8 bytes that are crafted
as follows:

```none
B0: 0x73 (manufacturer)
B1: any (serial[0])
B2: any (serial[1])
B3: B0 ^ B1 ^ B2 ^ 0x99 (check_byte_1)
B4: any (serial[2])
B5: any (serial[3])
B6: any (serial[4])
B7: any (serial[5])
```

The only thing missing to pass the check is `check_byte_2`, which is the XOR of
B4, B5, B6, B7. We don't control its value, but as it turns out it overlaps with
the LSB of the event `name`, which is a `char *` coming from `malloc()` and
therefore easily predictable since the program does very few heap allocations.
Using the given setup, this LSB is always `0xa0`. Therefore we can set any of
B4, B5, B6 or B7 to `0xa0`, and the rest to `0x00`.

In Python terms:

```py
user = b'X' * 0x14 + bytearray([
    0x73,        # manufacturer
    0x20, 0x41,  # serial[0:1 + 1]
    0x8b,        # 1st check byte (0x73 ^ 0x20 ^ 0x41 ^ 0x99)
    0xa0, 0x00,  # serial[2:4 + 1]
    0x00, 0x00,  # serial[4:6 + 1]
    # 2nd check byte should be 0xa0
])
assert len(user) == 28
```

After creating a wallet and trying to buy a VIP ticket for a non-existing event
with the user crafted above, we can then keep the same wallet connection open
and read pages 10 to 13 (included) of a non-existing ticket in our wallet. The
`nfc_verify_tag()` check will pass and we will read the VIP invitation code left
by `buy_vip_ticket()` on the stack.
